{"/home/travis/build/npmtest/node-npmtest-watchr/test.js":"/* istanbul instrument in package npmtest_watchr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-watchr/lib.npmtest_watchr.js":"/* istanbul instrument in package npmtest_watchr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_watchr = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_watchr = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-watchr/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-watchr && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_watchr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_watchr\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_watchr.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_watchr.rollup.js'] =\n            local.assetsDict['/assets.npmtest_watchr.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_watchr.__dirname + '/lib.npmtest_watchr.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-watchr/node_modules/watchr/index.js":"// 2016 March 8\n// https://github.com/bevry/editions\nmodule.exports = require('editions').requirePackage(__dirname, require)\n","/home/travis/build/npmtest/node-npmtest-watchr/node_modules/watchr/source/index.js":"/* @flow */\n/* eslint no-use-before-define:0 */\n'use strict'\n\n// Imports\nconst pathUtil = require('path')\nconst scandir = require('scandirectory')\nconst fsUtil = require('safefs')\nconst ignorefs = require('ignorefs')\nconst extendr = require('extendr')\nconst eachr = require('eachr')\nconst {TaskGroup} = require('taskgroup')\nconst {EventEmitter} = require('events')\n\n/* ::\nimport type {Stats, FSWatcher} from 'fs'\ntype StateEnum = \"pending\" | \"active\" | \"deleted\" | \"closed\"\ntype MethodEnum = \"watch\" | \"watchFile\"\ntype ErrorCallback = (error: ?Error) => void\ntype StatCallback = (error: ?Error, stat?: Stats) => void\ntype WatchChildOpts = {\n\tfullPath: string,\n\trelativePath: string,\n\tstat?: Stats\n}\ntype WatchSelfOpts = {\n\terrors?: Array<Error>,\n\tpreferredMethods?: Array<MethodEnum>\n}\ntype ListenerOpts = {\n\tmethod: MethodEnum,\n\targs: Array<any>\n}\ntype ResetOpts = {\n\treset?: boolean\n}\ntype IgnoreOpts = {\n\tignorePaths?: boolean,\n\tignoreHiddenFiles?: boolean,\n\tignoreCommonPatterns?: boolean,\n\tignoreCustomPatterns?: RegExp\n}\ntype WatcherOpts = IgnoreOpts & {\n\tstat?: Stats,\n\tinterval?: number,\n\tpersistent?: boolean,\n\tcatchupDelay?: number,\n\tpreferredMethods?: Array<MethodEnum>,\n\tfollowLinks?: boolean\n}\ntype WatcherConfig = {\n\tstat: ?Stats,\n\tinterval: number,\n\tpersistent: boolean,\n\tcatchupDelay: number,\n\tpreferredMethods: Array<MethodEnum>,\n\tfollowLinks: boolean,\n\tignorePaths: false | Array<string>,\n\tignoreHiddenFiles: boolean,\n\tignoreCommonPatterns: boolean,\n\tignoreCustomPatterns: ?RegExp\n}\n*/\n\n// Helper for error logging\nfunction errorToString (error /* :Error */) {\n\treturn error.stack.toString() || error.message || error.toString()\n}\n\n/**\nAlias for creating a new {@link Stalker} with some basic configuration\n@access public\n@param {string} path - the path to watch\n@param {function} changeListener - the change listener for {@link Watcher}\n@param {function} next - the completion callback for {@link Watcher#watch}\n@returns {Stalker}\n*/\nfunction open (path /* :string */, changeListener /* :function */, next /* :function */) {\n\tconst stalker = new Stalker(path)\n\tstalker.on('change', changeListener)\n\tstalker.watch({}, next)\n\treturn stalker\n}\n\n/**\nAlias for creating a new {@link Stalker}\n@access public\n@returns {Stalker}\n*/\nfunction create (...args /* :Array<any> */) {\n\treturn new Stalker(...args)\n}\n\n/**\nStalker\nA watcher of the watchers.\nEvents that are listened to on the stalker will also be listened to on the attached watcher.\nWhen the watcher is closed, the stalker's listeners will be removed.\nWhen all stalkers for a watcher are removed, the watcher will close.\n@protected\n@property {Object} watchers - static collection of all the watchers mapped by path\n@property {Watcher} watcher - the associated watcher for this stalker\n*/\nclass Stalker extends EventEmitter {\n\t/* :: static watchers: {[key:string]: Watcher}; */\n\t/* :: watcher: Watcher; */\n\n\t/**\n\t@param {string} path - the path to watch\n\t*/\n\tconstructor (path /* :string */) {\n\t\tsuper()\n\n\t\t// Ensure global watchers singleton\n\t\tif ( Stalker.watchers == null )  Stalker.watchers = {}\n\n\t\t// Add our watcher to the singleton\n\t\tif ( Stalker.watchers[path] == null )  Stalker.watchers[path] = new Watcher(path)\n\t\tthis.watcher = Stalker.watchers[path]\n\n\t\t// Add our stalker to the watcher\n\t\tif ( this.watcher.stalkers == null )  this.watcher.stalkers = []\n\t\tthis.watcher.stalkers.push(this)\n\n\t\t// If the watcher closes, remove our stalker and the watcher from the singleton\n\t\tthis.watcher.once('close', () => {\n\t\t\tthis.remove()\n\t\t\tdelete Stalker.watchers[path]\n\t\t})\n\n\t\t// Add the listener proxies\n\t\tthis.on('newListener', (eventName, listener) => this.watcher.on(eventName, listener))\n\t\tthis.on('removeListener', (eventName, listener) => this.watcher.removeListener(eventName, listener))\n\t}\n\n\t/**\n\tCleanly shutdown the stalker\n\t@private\n\t@returns {this}\n\t*/\n\tremove () {\n\t\t// Remove our stalker from the watcher\n\t\tconst index = this.watcher.stalkers.indexOf(this)\n\t\tif ( index !== -1 ) {\n\t\t\tthis.watcher.stalkers = this.watcher.stalkers.slice(0, index).concat(this.watcher.stalkers.slice(index + 1))\n\t\t}\n\n\t\t// Kill our stalker\n\t\tprocess.nextTick(() => {\n\t\t\tthis.removeAllListeners()\n\t\t})\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tClose the stalker, and if it is the last stalker for the path, close the watcher too\n\t@access public\n\t@param {string} [reason] - optional reason to provide for closure\n\t@returns {this}\n\t*/\n\tclose (reason /* :?string */) {\n\t\t// Remove our stalker\n\t\tthis.remove()\n\n\t\t// If it was the last stalker for the watcher, or if the path is deleted\n\t\t// Then close the watcher\n\t\tif ( reason === 'deleted' || this.watcher.stalkers.length === 0 ) {\n\t\t\tthis.watcher.close(reason || 'all stalkers are now gone')\n\t\t}\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tAlias for {@link Watcher#setConfig}\n\t@access public\n\t@returns {this}\n\t*/\n\tsetConfig (...args /* :Array<any> */) {\n\t\tthis.watcher.setConfig(...args)\n\t\treturn this\n\t}\n\n\t/**\n\tAlias for {@link Watcher#watch}\n\t@access public\n\t@returns {this}\n\t*/\n\twatch (...args /* :Array<any> */) {\n\t\tthis.watcher.watch(...args)\n\t\treturn this\n\t}\n}\n\n/**\nWatcher\nWatches a path and if its a directory, its children too, and emits change events for updates, deletions, and creations\n\nAvailable events:\n\n- `log(logLevel, ...args)` - emitted for debugging, child events are bubbled up\n- `close(reason)` - the watcher has been closed, perhaps for a reason\n- `change('update', fullPath, currentStat, previousStat)` - an update event has occured on the `fullPath`\n- `change('delete', fullPath, currentStat)` - an delete event has occured on the `fullPath`\n- `change('create', fullPath, null, previousStat)` - a create event has occured on the `fullPath`\n\n@protected\n@property {Array<Stalker>} stalkers - the associated stalkers for this watcher\n@property {string} path - the path to be watched\n@property {Stats} stat - the stat object for the path\n@property {FSWatcher} fswatcher - if the `watch` method was used, this is the FSWatcher instance for it\n@property {Object} children - a (relativePath => stalker) mapping of children\n@property {string} state - the current state of this watcher\n@property {TaskGroup} listenerTaskGroup - the TaskGroup instance for queuing listen events\n@property {number} listenerTimeout - the timeout result for queuing listen events\n@property {Object} config - the configuration options\n*/\nclass Watcher extends EventEmitter {\n\t/* :: stalkers: Array<Stalker>; */\n\n\t/* :: path: string; */\n\t/* :: stat: null | Stats; */\n\t/* :: fswatcher: null | FSWatcher; */\n\t/* :: children: {[path:string]: Stalker}; */\n\t/* :: state: StateEnum; */\n\t/* :: listenerTaskGroup: null | TaskGroup; */\n\t/* :: listenerTimeout: null | number; */\n\t/* :: config: WatcherConfig; */\n\n\t/**\n\t@param {string} path - the path to watch\n\t*/\n\tconstructor (path /* :string */) {\n\t\t// Construct the EventEmitter\n\t\tsuper()\n\n\t\t// Initialise properties\n\t\tthis.path = path\n\t\tthis.stat = null\n\t\tthis.fswatcher = null\n\t\tthis.children = {}\n\t\tthis.state = 'pending'\n\t\tthis.listenerTaskGroup = null\n\t\tthis.listenerTimeout = null\n\n\t\t// Initialize our configurable properties\n\t\tthis.config = {\n\t\t\tstat: null,\n\t\t\tinterval: 5007,\n\t\t\tpersistent: true,\n\t\t\tcatchupDelay: 2000,\n\t\t\tpreferredMethods: ['watch', 'watchFile'],\n\t\t\tfollowLinks: true,\n\t\t\tignorePaths: false,\n\t\t\tignoreHiddenFiles: false,\n\t\t\tignoreCommonPatterns: true,\n\t\t\tignoreCustomPatterns: null\n\t\t}\n\t}\n\n\t/**\n\tConfigure out Watcher\n\t@param {Object} opts - the configuration to use\n\t@param {Stats} [opts.stat] - A stat object for the path if we already have one, otherwise it will be fetched for us\n\t@param {number} [opts.interval=5007] - If the `watchFile` method was used, this is the interval to use for change detection if polling is needed\n\t@param {boolean} [opts.persistent=true] - If the `watchFile` method was used, this is whether or not watching should keep the node process alive while active\n\t@param {number} [opts.catchupDelay=2000] - This is the delay to wait after a change event to be able to detect swap file changes accurately (without a delay, swap files trigger a delete and creation event, with a delay they trigger a single update event)\n\t@param {Array<string>} [opts.preferredMethods=['watch', 'watchFile']] - The order of watch methods to attempt, if the first fails, move onto the second\n\t@param {boolean} [opts.followLinks=true] - If true, will use `fs.stat` instead of `fs.lstat`\n\t@param {Array<string>} [opts.ignorePaths=false] - Array of paths that should be ignored\n\t@param {boolean} [opts.ignoreHiddenFiles=false] - Whether to ignore files and directories that begin with a `.`\n\t@param {boolean} [opts.ignoreCommonPatterns=false] - Whether to ignore common undesirable paths (e.g. `.svn`, `.git`, `.DS_Store`, `thumbs.db`, etc)\n\t@param {RegExp} [opts.ignoreCustomPatterns] - A regular expression that if matched again the path will ignore the path\n\t@returns {this}\n\t*/\n\tsetConfig (opts /* :WatcherOpts */) {\n\t\t// Apply\n\t\textendr.extend(this.config, opts)\n\n\t\t// Stat\n\t\tif ( this.config.stat ) {\n\t\t\tthis.stat = this.config.stat\n\t\t\tdelete this.config.stat\n\t\t}\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tEmit a log event with the given arguments\n\t@param {Array<*>} args\n\t@returns {this}\n\t*/\n\tlog (...args /* :Array<any> */) {\n\t\t// Emit the log event\n\t\tthis.emit('log', ...args)\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tFetch the ignored configuration options into their own object\n\t@private\n\t@returns {Object}\n\t*/\n\tgetIgnoredOptions () {\n\t\t// Return the ignore options\n\t\treturn {\n\t\t\tignorePaths: this.config.ignorePaths,\n\t\t\tignoreHiddenFiles: this.config.ignoreHiddenFiles,\n\t\t\tignoreCommonPatterns: this.config.ignoreCommonPatterns,\n\t\t\tignoreCustomPatterns: this.config.ignoreCustomPatterns\n\t\t}\n\t}\n\n\t/**\n\tCheck whether or not a path should be ignored or not based on our current configuration options\n\t@private\n\t@param {String} path - the path (likely of a child)\n\t@returns {boolean}\n\t*/\n\tisIgnoredPath (path /* :string */) {\n\t\t// Ignore?\n\t\tconst ignore = ignorefs.isIgnoredPath(path, this.getIgnoredOptions())\n\n\t\t// Return\n\t\treturn ignore\n\t}\n\n\t/**\n\tGet the stat for the path of the watcher\n\tIf the stat already exists and `opts.reset` is `false`, then just use the current stat, otherwise fetch a new stat and apply it to the watcher\n\t@param {Object} opts\n\t@param {boolean} [opts.reset=false]\n\t@param  {function} next - completion callback with signature `error:?Error, stat?:Stats`\n\t@returns {this}\n\t*/\n\tgetStat (opts /* :ResetOpts */, next /* :StatCallback */) {\n\t\t// Figure out what stat method we want to use\n\t\tconst method = this.config.followLinks ? 'stat' : 'lstat'\n\n\t\t// Fetch\n\t\tif ( this.stat && opts.reset !== true ) {\n\t\t\tnext(null, this.stat)\n\t\t}\n\t\telse {\n\t\t\tfsUtil[method](this.path, (err, stat) => {\n\t\t\t\tif ( err )  return next(err)\n\t\t\t\tthis.stat = stat\n\t\t\t\treturn next(null, stat)\n\t\t\t})\n\t\t}\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tWatch and WatchFile Listener\n\tThe listener attached to the `watch` and `watchFile` watching methods.\n\n\tThings to note:\n\t- `watchFile` method:\n\t\t- Arguments:\n\t\t\t- currentStat - the updated stat of the changed file\n\t\t\t\t- Exists even for deleted/renamed files\n\t\t\t- previousStat - the last old stat of the changed file\n\t\t\t\t- Is accurate, however we already have this\n\t\t- For renamed files, it will will fire on the directory and the file\n\t- `watch` method:\n\t\t- Arguments:\n\t\t\t- eventName - either 'rename' or 'change'\n\t\t\t\t- THIS VALUE IS ALWAYS UNRELIABLE AND CANNOT BE TRUSTED\n\t\t\t- filename - child path of the file that was triggered\n\t\t\t\t- This value can also be unrealiable at times\n\t- both methods:\n\t\t- For deleted and changed files, it will fire on the file\n\t\t- For new files, it will fire on the directory\n\n\tOutput arguments for your emitted event will be:\n\t- for updated files the arguments will be: `'update', fullPath, currentStat, previousStat`\n\t- for created files the arguments will be: `'create', fullPath, currentStat, null`\n\t- for deleted files the arguments will be: `'delete', fullPath, null, previousStat`\n\n\tIn the future we will add:\n\t- for renamed files: 'rename', fullPath, currentStat, previousStat, newFullPath\n\t- rename is possible as the stat.ino is the same for the delete and create\n\n\t@private\n\t@param {Object} opts\n\t@param {string} [opts.method] - the watch method that was used\n\t@param {Array<*>} [opts.args] - the arguments from the watching method\n\t@param {function} [next] - the optional completion callback with the signature `(error:?Error)`\n\t@returns {this}\n\t*/\n\tlistener (opts /* :ListenerOpts */, next /* ::?:ErrorCallback */) {\n\t\t// Prepare\n\t\tconst config = this.config\n\t\tconst method = opts.method\n\t\tif ( !next ) {\n\t\t\tnext = (err) => {\n\t\t\t\tif ( err ) {\n\t\t\t\t\tthis.emit('error', err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Prepare properties\n\t\tlet currentStat = null\n\t\tlet previousStat = null\n\n\t\t// Log\n\t\tthis.log('debug', `watch via ${method} method fired on: ${this.path}`)\n\n\t\t// Delay the execution of the listener tasks, to once the change events have stopped firing\n\t\tif ( this.listenerTimeout != null ) {\n\t\t\tclearTimeout(this.listenerTimeout)\n\t\t}\n\t\tthis.listenerTimeout = setTimeout(() => {\n\t\t\tconst tasks = this.listenerTaskGroup\n\t\t\tif ( tasks ) {\n\t\t\t\tthis.listenerTaskGroup = null\n\t\t\t\tthis.listenerTimeout = null\n\t\t\t\ttasks.run()\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.emit('error', new Error('unexpected state'))\n\t\t\t}\n\t\t}, config.catchupDelay || 0)\n\n\t\t// We are a subsequent listener, in which case, just listen to the first listener tasks\n\t\tif ( this.listenerTaskGroup != null ) {\n\t\t\tthis.listenerTaskGroup.done(next)\n\t\t\treturn this\n\t\t}\n\n\t\t// Start the detection process\n\t\tconst tasks = this.listenerTaskGroup = new TaskGroup(`listener tasks for ${this.path}`, {domain: false}).done(next)\n\t\ttasks.addTask('check if the file still exists', (complete) => {\n\t\t\t// Log\n\t\t\tthis.log('debug', `watch evaluating on: ${this.path} [state: ${this.state}]`)\n\n\t\t\t// Check if this is still needed\n\t\t\tif ( this.state !== 'active' ) {\n\t\t\t\tthis.log('debug', `watch discarded on: ${this.path}`)\n\t\t\t\ttasks.clearRemaining()\n\t\t\t\treturn complete()\n\t\t\t}\n\n\t\t\t// Check if the file still exists\n\t\t\tfsUtil.exists(this.path, (exists) => {\n\t\t\t\t// Apply local global property\n\t\t\t\tpreviousStat = this.stat\n\n\t\t\t\t// If the file still exists, then update the stat\n\t\t\t\tif ( exists === false ) {\n\t\t\t\t\t// Log\n\t\t\t\t\tthis.log('debug', `watch emit delete: ${this.path}`)\n\n\t\t\t\t\t// Apply\n\t\t\t\t\tthis.stat = null\n\t\t\t\t\tthis.close('deleted')\n\t\t\t\t\tthis.emit('change', 'delete', this.path, null, previousStat)\n\n\t\t\t\t\t// Clear the remaining tasks, as they are no longer needed\n\t\t\t\t\ttasks.clearRemaining()\n\t\t\t\t\treturn complete()\n\t\t\t\t}\n\n\t\t\t\t// Update the stat of the fil\n\t\t\t\tthis.getStat({reset: true}, (err, stat) => {\n\t\t\t\t\t// Check\n\t\t\t\t\tif ( err )  return complete(err)\n\n\t\t\t\t\t// Update\n\t\t\t\t\tcurrentStat = stat\n\n\t\t\t\t\t// Complete\n\t\t\t\t\treturn complete()\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\ttasks.addTask('check if the file has changed', (complete) => {\n\t\t\t// Ensure stats exist\n\t\t\tif ( !currentStat || !previousStat ) {\n\t\t\t\treturn complete(new Error('unexpected state'))\n\t\t\t}\n\n\t\t\t// Check if there is a different file at the same location\n\t\t\t// If so, we will need to rewatch the location and the children\n\t\t\tif ( currentStat.ino.toString() !== previousStat.ino.toString() ) {\n\t\t\t\tthis.log('debug', `watch found replaced: ${this.path}`, currentStat, previousStat)\n\t\t\t\t// note this will close the entire tree of listeners and reinstate them\n\t\t\t\t// however, as this is probably for a file, it is probably not that bad\n\t\t\t\treturn this.watch({reset: true}, complete)\n\t\t\t}\n\n\t\t\t// Check if the file or directory has been modified\n\t\t\tif ( currentStat.mtime.toString() !== previousStat.mtime.toString() ) {\n\t\t\t\tthis.log('debug', `watch found modification: ${this.path}`, previousStat, currentStat)\n\t\t\t\treturn complete()\n\t\t\t}\n\n\t\t\t// Otherwise it is the same, and nothing is needed to be done\n\t\t\telse {\n\t\t\t\ttasks.clearRemaining()\n\t\t\t\treturn complete()\n\t\t\t}\n\t\t})\n\n\t\ttasks.addGroup('check what has changed', (addGroup, addTask, done) => {\n\t\t\t// Ensure stats exist\n\t\t\tif ( !currentStat || !previousStat ) {\n\t\t\t\treturn done(new Error('unexpected state'))\n\t\t\t}\n\n\t\t\t// Set this sub group to execute in parallel\n\t\t\tthis.setConfig({concurrency: 0})\n\n\t\t\t// So let's check if we are a directory\n\t\t\tif ( currentStat.isDirectory() === false ) {\n\t\t\t\t// If we are a file, lets simply emit the change event\n\t\t\t\tthis.log('debug', `watch emit update: ${this.path}`)\n\t\t\t\tthis.emit('change', 'update', this.path, currentStat, previousStat)\n\t\t\t\treturn done()\n\t\t\t}\n\n\t\t\t// We are a direcotry\n\t\t\t// Chances are something actually happened to a child (rename or delete)\n\t\t\t// and if we are the same, then we should scan our children to look for renames and deletes\n\t\t\tfsUtil.readdir(this.path, (err, newFileRelativePaths) => {\n\t\t\t\t// Error?\n\t\t\t\tif ( err )  return done(err)\n\n\t\t\t\t// Log\n\t\t\t\tthis.log('debug', `watch read dir: ${this.path}`, newFileRelativePaths)\n\n\t\t\t\t// Find deleted files\n\t\t\t\teachr(this.children, (child, childFileRelativePath) => {\n\t\t\t\t\t// Skip if the file still exists\n\t\t\t\t\tif ( newFileRelativePaths.indexOf(childFileRelativePath) !== -1 )  return\n\n\t\t\t\t\t// Fetch full path\n\t\t\t\t\tconst childFileFullPath = pathUtil.join(this.path, childFileRelativePath)\n\n\t\t\t\t\t// Skip if ignored file\n\t\t\t\t\tif ( this.isIgnoredPath(childFileFullPath) ) {\n\t\t\t\t\t\tthis.log('debug', `watch ignored delete: ${childFileFullPath} via: ${this.path}`)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit the event and note the change\n\t\t\t\t\tthis.log('debug', `watch emit delete: ${childFileFullPath} via: ${this.path}`)\n\t\t\t\t\tconst childPreviousStat = child.watcher.stat\n\t\t\t\t\tchild.close('deleted')\n\t\t\t\t\tthis.emit('change', 'delete', childFileFullPath, null, childPreviousStat)\n\t\t\t\t})\n\n\t\t\t\t// Find new files\n\t\t\t\teachr(newFileRelativePaths, (childFileRelativePath) => {\n\t\t\t\t\t// Skip if we are already watching this file\n\t\t\t\t\tif ( this.children[childFileRelativePath] != null )  return\n\n\t\t\t\t\t// Fetch full path\n\t\t\t\t\tconst childFileFullPath = pathUtil.join(this.path, childFileRelativePath)\n\n\t\t\t\t\t// Skip if ignored file\n\t\t\t\t\tif ( this.isIgnoredPath(childFileFullPath) ) {\n\t\t\t\t\t\tthis.log('debug', `watch ignored create: ${childFileFullPath} via: ${this.path}`)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit the event and note the change\n\t\t\t\t\taddTask('watch the new child', (complete) => {\n\t\t\t\t\t\tthis.log('debug', `watch determined create: ${childFileFullPath} via: ${this.path}`)\n\t\t\t\t\t\tif ( this.children[childFileRelativePath] != null ) {\n\t\t\t\t\t\t\treturn complete()  // this should never occur\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst child = this.watchChild({\n\t\t\t\t\t\t\tfullPath: childFileFullPath,\n\t\t\t\t\t\t\trelativePath: childFileRelativePath\n\t\t\t\t\t\t}, (err) => {\n\t\t\t\t\t\t\tif ( err )  return complete(err)\n\t\t\t\t\t\t\tthis.emit('change', 'create', childFileFullPath, child.watcher.stat, null)\n\t\t\t\t\t\t\treturn complete()\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\t// Read the directory, finished adding tasks to the group\n\t\t\t\treturn done()\n\t\t\t})\n\t\t})\n\n\t\t// Tasks are executed via the timeout thing earlier\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tClose the watching abilities of this watcher and its children if it has any\n\tAnd mark the state as deleted or closed, dependning on the reason\n\t@param {string} [reason='unknown']\n\t@returns {this}\n\t*/\n\tclose (reason /* :string */ = 'unknown') {\n\t\t// Nothing to do? Already closed?\n\t\tif ( this.state !== 'active' )  return this\n\n\t\t// Close\n\t\tthis.log('debug', `close: ${this.path}`)\n\n\t\t// Close our children\n\t\teachr(this.children, (child) => {\n\t\t\tchild.close(reason)\n\t\t})\n\n\t\t// Close watch listener\n\t\tif ( this.fswatcher != null ) {\n\t\t\tthis.fswatcher.close()\n\t\t\tthis.fswatcher = null\n\t\t}\n\t\telse {\n\t\t\tfsUtil.unwatchFile(this.path)\n\t\t}\n\n\t\t// Updated state\n\t\tif ( reason === 'deleted' ) {\n\t\t\tthis.state = 'deleted'\n\t\t}\n\t\telse {\n\t\t\tthis.state = 'closed'\n\t\t}\n\n\t\t// Emit our close event\n\t\tthis.log('debug', `watch closed because ${reason} on ${this.path}`)\n\t\tthis.emit('close', reason)\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tCreate the child watcher/stalker for a given sub path of this watcher with inherited configuration\n\tOnce created, attach it to `this.children` and bubble `log` and `change` events\n\tIf the child closes, then delete it from `this.children`\n\t@private\n\t@param {Object} opts\n\t@param {string} opts.fullPath\n\t@param {string} opts.relativePath\n\t@param {Stats} [opts.stat]\n\t@param {function} next - completion callback with signature `error:?Error`\n\t@returns {this}\n\t*/\n\twatchChild (opts /* :WatchChildOpts */, next /* :ErrorCallback */) /* :Stalker */ {\n\t\t// Prepare\n\t\tconst watchr = this\n\n\t\t// Create the child\n\t\tconst child = create(opts.fullPath)\n\n\t\t// Apply the child\n\t\tthis.children[opts.relativePath] = child\n\n\t\t// Add the extra listaeners\n\t\tchild.once('close', () => delete watchr.children[opts.relativePath])\n\t\tchild.on('log', (...args) => watchr.emit('log', ...args))\n\t\tchild.on('change', (...args) => watchr.emit('change', ...args))\n\n\t\t// Add the extra configuration\n\t\tchild.setConfig({\n\t\t\t// Custom\n\t\t\tstat: opts.stat,\n\n\t\t\t// Inherit\n\t\t\tinterval: this.config.interval,\n\t\t\tpersistent: this.config.persistent,\n\t\t\tcatchupDelay: this.config.catchupDelay,\n\t\t\tpreferredMethods: this.config.preferredMethods,\n\t\t\tignorePaths: this.config.ignorePaths,\n\t\t\tignoreHiddenFiles: this.config.ignoreHiddenFiles,\n\t\t\tignoreCommonPatterns: this.config.ignoreCommonPatterns,\n\t\t\tignoreCustomPatterns: this.config.ignoreCustomPatterns,\n\t\t\tfollowLinks: this.config.followLinks\n\t\t})\n\n\t\t// Start the watching\n\t\tchild.watch(next)\n\n\t\t// Return the child\n\t\treturn child\n\t}\n\n\t/**\n\tRead the directory at our given path and watch each child\n\t@private\n\t@param {Object} opts - not currently used\n\t@param {function} next - completion callback with signature `error:?Error`\n\t@returns {this}\n\t*/\n\twatchChildren (opts /* :Object */, next /* :ErrorCallback */) {\n\t\t// Prepare\n\t\tconst watchr = this\n\n\t\t// Check stat\n\t\tif ( this.stat == null ) {\n\t\t\tnext(new Error('unexpected state'))\n\t\t\treturn this\n\t\t}\n\n\t\t// Cycle through the directory if necessary\n\t\tif ( this.stat.isDirectory() ) {\n\t\t\tscandir({\n\t\t\t\t// Path\n\t\t\t\tpath: this.path,\n\n\t\t\t\t// Options\n\t\t\t\tignorePaths: this.config.ignorePaths,\n\t\t\t\tignoreHiddenFiles: this.config.ignoreHiddenFiles,\n\t\t\t\tignoreCommonPatterns: this.config.ignoreCommonPatterns,\n\t\t\t\tignoreCustomPatterns: this.config.ignoreCustomPatterns,\n\t\t\t\trecurse: false,\n\n\t\t\t\t// Next\n\t\t\t\tnext,\n\n\t\t\t\t// File and Directory Actions\n\t\t\t\taction (fullPath, relativePath, nextFile) {\n\t\t\t\t\t// Check we are still releveant\n\t\t\t\t\tif ( watchr.state !== 'active' ) {\n\t\t\t\t\t\treturn nextFile(null, true)  // skip without error\n\t\t\t\t\t}\n\n\t\t\t\t\t// Watch this child\n\t\t\t\t\twatchr.watchChild({fullPath, relativePath}, nextFile)\n\t\t\t\t}\n\t\t\t})\n\n\t\t}\n\t\telse {\n\t\t\tnext()\n\t\t}\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tSetup the watching using the specified method\n\t@private\n\t@param {string} method\n\t@param {function} next - completion callback with signature `error:?Error`\n\t@returns {void}\n\t*/\n\twatchMethod (method /* :MethodEnum */, next /* :ErrorCallback */) /* :void */ {\n\t\tif ( method === 'watch' ) {\n\t\t\t// Check\n\t\t\tif ( fsUtil.watch == null ) {\n\t\t\t\tconst err = new Error('watch method is not supported on this environment, fs.watch does not exist')\n\t\t\t\tnext(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Watch\n\t\t\ttry {\n\t\t\t\tthis.fswatcher = fsUtil.watch(this.path, (...args) => this.listener({method, args}))\n\t\t\t\t// must pass the listener here instead of doing fswatcher.on('change', opts.listener)\n\t\t\t\t// as the latter is not supported on node 0.6 (only 0.8+)\n\t\t\t}\n\t\t\tcatch ( err ) {\n\t\t\t\tnext(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Success\n\t\t\tnext()\n\t\t\treturn\n\t\t}\n\t\telse if ( method === 'watchFile' ) {\n\t\t\t// Check\n\t\t\tif ( fsUtil.watchFile == null ) {\n\t\t\t\tconst err = new Error('watchFile method is not supported on this environment, fs.watchFile does not exist')\n\t\t\t\tnext(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Watch\n\t\t\ttry {\n\t\t\t\tfsUtil.watchFile(this.path, {\n\t\t\t\t\tpersistent: this.config.persistent,\n\t\t\t\t\tinterval: this.config.interval\n\t\t\t\t}, (...args) => this.listener({method, args}))\n\t\t\t}\n\t\t\tcatch ( err ) {\n\t\t\t\tnext(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Success\n\t\t\tnext()\n\t\t\treturn\n\t\t}\n\t\telse {\n\t\t\tconst err = new Error('unknown watch method')\n\t\t\tnext(err)\n\t\t\treturn\n\t\t}\n\t}\n\n\t/**\n\tSetup watching for our path, in the order of the preferred methods\n\t@private\n\t@param {Object} opts\n\t@param {Array<Error>} [opts.errors] - the current errors that we have received attempting the preferred methods\n\t@param {Array<string>} [opts.preferredMethods] - fallback to the configuration if not specified\n\t@param {function} next - completion callback with signature `error:?Error`\n\t@returns {this}\n\t*/\n\twatchSelf (opts /* :WatchSelfOpts */, next /* :ErrorCallback */) {\n\t\t// Prepare\n\t\tconst {errors = []} = opts\n\t\tlet {preferredMethods = this.config.preferredMethods} = opts\n\t\topts.errors = errors\n\t\topts.preferredMethods = preferredMethods\n\n\t\t// Attempt the watch methods\n\t\tif ( preferredMethods.length ) {\n\t\t\tconst method = preferredMethods[0]\n\t\t\tthis.watchMethod(method, (err) => {\n\t\t\t\tif ( err ) {\n\t\t\t\t\t// try again with the next preferred method\n\t\t\t\t\tpreferredMethods = preferredMethods.slice(1)\n\t\t\t\t\terrors.push(err)\n\t\t\t\t\tthis.watchSelf({errors, preferredMethods}, next)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Apply\n\t\t\t\tthis.state = 'active'\n\n\t\t\t\t// Forward\n\t\t\t\tnext()\n\t\t\t})\n\t\t}\n\t\telse {\n\t\t\tconst errors = opts.errors.map((error) => error.stack || error.message || error).join('\\n')\n\t\t\tconst err = new Error(`no watch methods left to try, failures are:\\n${errors}`)\n\t\t\tnext(err)\n\t\t}\n\n\t\t// Chain\n\t\treturn this\n\t}\n\n\t/**\n\tSetup watching for our path, and our children\n\tIf we are already watching and `opts.reset` is not `true` then all done\n\tOtherwise, close the current watchers for us and the children via {@link Watcher#close} and setup new ones\n\t@public\n\t@param {Object} [opts]\n\t@param {boolean} [opts.reset=false] - should we always close existing watchers and setup new watchers\n\t@param {function} next - completion callback with signature `error:?Error`\n\t@param {Array<*>} args - ignore this argument, it is used just to handle the optional `opts` argument\n\t@returns {this}\n\t*/\n\twatch (...args /* :Array<any> */) {\n\t\t// Handle overloaded signature\n\t\tlet opts /* :ResetOpts */, next /* :ErrorCallback */\n\t\tif ( args.length === 1 ) {\n\t\t\topts = {}\n\t\t\tnext = args[0]\n\t\t}\n\t\telse if ( args.length === 2 ) {\n\t\t\topts = args[0]\n\t\t\tnext = args[1]\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('unknown arguments')\n\t\t}\n\n\t\t// Check\n\t\tif ( this.state === 'active' && opts.reset !== true ) {\n\t\t\tnext()\n\t\t\treturn this\n\t\t}\n\n\t\t// Close our all watch listeners\n\t\tthis.close()\n\n\t\t// Log\n\t\tthis.log('debug', `watch init: ${this.path}`)\n\n\t\t// Fetch the stat then try again\n\t\tthis.getStat({}, (err) => {\n\t\t\tif ( err )  return next(err)\n\n\t\t\t// Watch ourself\n\t\t\tthis.watchSelf({}, (err) => {\n\t\t\t\tif ( err )  return next(err)\n\n\t\t\t\t// Watch the children\n\t\t\t\tthis.watchChildren({}, (err) => {\n\t\t\t\t\tif ( err ) {\n\t\t\t\t\t\tthis.close('child failure')\n\t\t\t\t\t\tthis.log('debug', `watch failed on [${this.path}] with ${errorToString(err)}`)\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.log('debug', `watch success on [${this.path}]`)\n\t\t\t\t\t}\n\t\t\t\t\treturn next(err)\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\t// Chain\n\t\treturn this\n\t}\n}\n\n// Now let's provide node.js with our public API\n// In other words, what the application that calls us has access to\nmodule.exports = {open, create, Stalker, Watcher}\n","/home/travis/build/npmtest/node-npmtest-watchr/node_modules/watchr/es2015/index.js":"/* @flow */\n/* eslint no-use-before-define:0 */\n'use strict';\n\n// Imports\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar pathUtil = require('path');\nvar scandir = require('scandirectory');\nvar fsUtil = require('safefs');\nvar ignorefs = require('ignorefs');\nvar extendr = require('extendr');\nvar eachr = require('eachr');\n\nvar _require = require('taskgroup');\n\nvar TaskGroup = _require.TaskGroup;\n\nvar _require2 = require('events');\n\nvar EventEmitter = _require2.EventEmitter;\n\n/* ::\nimport type {Stats, FSWatcher} from 'fs'\ntype StateEnum = \"pending\" | \"active\" | \"deleted\" | \"closed\"\ntype MethodEnum = \"watch\" | \"watchFile\"\ntype ErrorCallback = (error: ?Error) => void\ntype StatCallback = (error: ?Error, stat?: Stats) => void\ntype WatchChildOpts = {\n\tfullPath: string,\n\trelativePath: string,\n\tstat?: Stats\n}\ntype WatchSelfOpts = {\n\terrors?: Array<Error>,\n\tpreferredMethods?: Array<MethodEnum>\n}\ntype ListenerOpts = {\n\tmethod: MethodEnum,\n\targs: Array<any>\n}\ntype ResetOpts = {\n\treset?: boolean\n}\ntype IgnoreOpts = {\n\tignorePaths?: boolean,\n\tignoreHiddenFiles?: boolean,\n\tignoreCommonPatterns?: boolean,\n\tignoreCustomPatterns?: RegExp\n}\ntype WatcherOpts = IgnoreOpts & {\n\tstat?: Stats,\n\tinterval?: number,\n\tpersistent?: boolean,\n\tcatchupDelay?: number,\n\tpreferredMethods?: Array<MethodEnum>,\n\tfollowLinks?: boolean\n}\ntype WatcherConfig = {\n\tstat: ?Stats,\n\tinterval: number,\n\tpersistent: boolean,\n\tcatchupDelay: number,\n\tpreferredMethods: Array<MethodEnum>,\n\tfollowLinks: boolean,\n\tignorePaths: false | Array<string>,\n\tignoreHiddenFiles: boolean,\n\tignoreCommonPatterns: boolean,\n\tignoreCustomPatterns: ?RegExp\n}\n*/\n\n// Helper for error logging\n\nfunction errorToString(error /* :Error */) {\n\treturn error.stack.toString() || error.message || error.toString();\n}\n\n/**\nAlias for creating a new {@link Stalker} with some basic configuration\n@access public\n@param {string} path - the path to watch\n@param {function} changeListener - the change listener for {@link Watcher}\n@param {function} next - the completion callback for {@link Watcher#watch}\n@returns {Stalker}\n*/\nfunction open(path /* :string */, changeListener /* :function */, next /* :function */) {\n\tvar stalker = new Stalker(path);\n\tstalker.on('change', changeListener);\n\tstalker.watch({}, next);\n\treturn stalker;\n}\n\n/**\nAlias for creating a new {@link Stalker}\n@access public\n@returns {Stalker}\n*/\nfunction create() /* :Array<any> */{\n\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\targs[_key] = arguments[_key];\n\t}\n\n\treturn new (Function.prototype.bind.apply(Stalker, [null].concat(args)))();\n}\n\n/**\nStalker\nA watcher of the watchers.\nEvents that are listened to on the stalker will also be listened to on the attached watcher.\nWhen the watcher is closed, the stalker's listeners will be removed.\nWhen all stalkers for a watcher are removed, the watcher will close.\n@protected\n@property {Object} watchers - static collection of all the watchers mapped by path\n@property {Watcher} watcher - the associated watcher for this stalker\n*/\n\nvar Stalker = function (_EventEmitter) {\n\t_inherits(Stalker, _EventEmitter);\n\n\t/* :: static watchers: {[key:string]: Watcher}; */\n\t/* :: watcher: Watcher; */\n\n\t/**\n @param {string} path - the path to watch\n */\n\tfunction Stalker(path /* :string */) {\n\t\t_classCallCheck(this, Stalker);\n\n\t\t// Ensure global watchers singleton\n\t\tvar _this = _possibleConstructorReturn(this, (Stalker.__proto__ || Object.getPrototypeOf(Stalker)).call(this));\n\n\t\tif (Stalker.watchers == null) Stalker.watchers = {};\n\n\t\t// Add our watcher to the singleton\n\t\tif (Stalker.watchers[path] == null) Stalker.watchers[path] = new Watcher(path);\n\t\t_this.watcher = Stalker.watchers[path];\n\n\t\t// Add our stalker to the watcher\n\t\tif (_this.watcher.stalkers == null) _this.watcher.stalkers = [];\n\t\t_this.watcher.stalkers.push(_this);\n\n\t\t// If the watcher closes, remove our stalker and the watcher from the singleton\n\t\t_this.watcher.once('close', function () {\n\t\t\t_this.remove();\n\t\t\tdelete Stalker.watchers[path];\n\t\t});\n\n\t\t// Add the listener proxies\n\t\t_this.on('newListener', function (eventName, listener) {\n\t\t\treturn _this.watcher.on(eventName, listener);\n\t\t});\n\t\t_this.on('removeListener', function (eventName, listener) {\n\t\t\treturn _this.watcher.removeListener(eventName, listener);\n\t\t});\n\t\treturn _this;\n\t}\n\n\t/**\n Cleanly shutdown the stalker\n @private\n @returns {this}\n */\n\n\n\t_createClass(Stalker, [{\n\t\tkey: 'remove',\n\t\tvalue: function remove() {\n\t\t\tvar _this2 = this;\n\n\t\t\t// Remove our stalker from the watcher\n\t\t\tvar index = this.watcher.stalkers.indexOf(this);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.watcher.stalkers = this.watcher.stalkers.slice(0, index).concat(this.watcher.stalkers.slice(index + 1));\n\t\t\t}\n\n\t\t\t// Kill our stalker\n\t\t\tprocess.nextTick(function () {\n\t\t\t\t_this2.removeAllListeners();\n\t\t\t});\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Close the stalker, and if it is the last stalker for the path, close the watcher too\n  @access public\n  @param {string} [reason] - optional reason to provide for closure\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'close',\n\t\tvalue: function close(reason /* :?string */) {\n\t\t\t// Remove our stalker\n\t\t\tthis.remove();\n\n\t\t\t// If it was the last stalker for the watcher, or if the path is deleted\n\t\t\t// Then close the watcher\n\t\t\tif (reason === 'deleted' || this.watcher.stalkers.length === 0) {\n\t\t\t\tthis.watcher.close(reason || 'all stalkers are now gone');\n\t\t\t}\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Alias for {@link Watcher#setConfig}\n  @access public\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'setConfig',\n\t\tvalue: function setConfig() /* :Array<any> */{\n\t\t\tvar _watcher;\n\n\t\t\t(_watcher = this.watcher).setConfig.apply(_watcher, arguments);\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Alias for {@link Watcher#watch}\n  @access public\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'watch',\n\t\tvalue: function watch() /* :Array<any> */{\n\t\t\tvar _watcher2;\n\n\t\t\t(_watcher2 = this.watcher).watch.apply(_watcher2, arguments);\n\t\t\treturn this;\n\t\t}\n\t}]);\n\n\treturn Stalker;\n}(EventEmitter);\n\n/**\nWatcher\nWatches a path and if its a directory, its children too, and emits change events for updates, deletions, and creations\n\nAvailable events:\n\n- `log(logLevel, ...args)` - emitted for debugging, child events are bubbled up\n- `close(reason)` - the watcher has been closed, perhaps for a reason\n- `change('update', fullPath, currentStat, previousStat)` - an update event has occured on the `fullPath`\n- `change('delete', fullPath, currentStat)` - an delete event has occured on the `fullPath`\n- `change('create', fullPath, null, previousStat)` - a create event has occured on the `fullPath`\n\n@protected\n@property {Array<Stalker>} stalkers - the associated stalkers for this watcher\n@property {string} path - the path to be watched\n@property {Stats} stat - the stat object for the path\n@property {FSWatcher} fswatcher - if the `watch` method was used, this is the FSWatcher instance for it\n@property {Object} children - a (relativePath => stalker) mapping of children\n@property {string} state - the current state of this watcher\n@property {TaskGroup} listenerTaskGroup - the TaskGroup instance for queuing listen events\n@property {number} listenerTimeout - the timeout result for queuing listen events\n@property {Object} config - the configuration options\n*/\n\n\nvar Watcher = function (_EventEmitter2) {\n\t_inherits(Watcher, _EventEmitter2);\n\n\t/* :: stalkers: Array<Stalker>; */\n\n\t/* :: path: string; */\n\t/* :: stat: null | Stats; */\n\t/* :: fswatcher: null | FSWatcher; */\n\t/* :: children: {[path:string]: Stalker}; */\n\t/* :: state: StateEnum; */\n\t/* :: listenerTaskGroup: null | TaskGroup; */\n\t/* :: listenerTimeout: null | number; */\n\t/* :: config: WatcherConfig; */\n\n\t/**\n @param {string} path - the path to watch\n */\n\tfunction Watcher(path /* :string */) {\n\t\t_classCallCheck(this, Watcher);\n\n\t\t// Initialise properties\n\t\tvar _this3 = _possibleConstructorReturn(this, (Watcher.__proto__ || Object.getPrototypeOf(Watcher)).call(this));\n\t\t// Construct the EventEmitter\n\n\n\t\t_this3.path = path;\n\t\t_this3.stat = null;\n\t\t_this3.fswatcher = null;\n\t\t_this3.children = {};\n\t\t_this3.state = 'pending';\n\t\t_this3.listenerTaskGroup = null;\n\t\t_this3.listenerTimeout = null;\n\n\t\t// Initialize our configurable properties\n\t\t_this3.config = {\n\t\t\tstat: null,\n\t\t\tinterval: 5007,\n\t\t\tpersistent: true,\n\t\t\tcatchupDelay: 2000,\n\t\t\tpreferredMethods: ['watch', 'watchFile'],\n\t\t\tfollowLinks: true,\n\t\t\tignorePaths: false,\n\t\t\tignoreHiddenFiles: false,\n\t\t\tignoreCommonPatterns: true,\n\t\t\tignoreCustomPatterns: null\n\t\t};\n\t\treturn _this3;\n\t}\n\n\t/**\n Configure out Watcher\n @param {Object} opts - the configuration to use\n @param {Stats} [opts.stat] - A stat object for the path if we already have one, otherwise it will be fetched for us\n @param {number} [opts.interval=5007] - If the `watchFile` method was used, this is the interval to use for change detection if polling is needed\n @param {boolean} [opts.persistent=true] - If the `watchFile` method was used, this is whether or not watching should keep the node process alive while active\n @param {number} [opts.catchupDelay=2000] - This is the delay to wait after a change event to be able to detect swap file changes accurately (without a delay, swap files trigger a delete and creation event, with a delay they trigger a single update event)\n @param {Array<string>} [opts.preferredMethods=['watch', 'watchFile']] - The order of watch methods to attempt, if the first fails, move onto the second\n @param {boolean} [opts.followLinks=true] - If true, will use `fs.stat` instead of `fs.lstat`\n @param {Array<string>} [opts.ignorePaths=false] - Array of paths that should be ignored\n @param {boolean} [opts.ignoreHiddenFiles=false] - Whether to ignore files and directories that begin with a `.`\n @param {boolean} [opts.ignoreCommonPatterns=false] - Whether to ignore common undesirable paths (e.g. `.svn`, `.git`, `.DS_Store`, `thumbs.db`, etc)\n @param {RegExp} [opts.ignoreCustomPatterns] - A regular expression that if matched again the path will ignore the path\n @returns {this}\n */\n\n\n\t_createClass(Watcher, [{\n\t\tkey: 'setConfig',\n\t\tvalue: function setConfig(opts /* :WatcherOpts */) {\n\t\t\t// Apply\n\t\t\textendr.extend(this.config, opts);\n\n\t\t\t// Stat\n\t\t\tif (this.config.stat) {\n\t\t\t\tthis.stat = this.config.stat;\n\t\t\t\tdelete this.config.stat;\n\t\t\t}\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Emit a log event with the given arguments\n  @param {Array<*>} args\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'log',\n\t\tvalue: function log() /* :Array<any> */{\n\t\t\tfor (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\targs[_key2] = arguments[_key2];\n\t\t\t}\n\n\t\t\t// Emit the log event\n\t\t\tthis.emit.apply(this, ['log'].concat(args));\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Fetch the ignored configuration options into their own object\n  @private\n  @returns {Object}\n  */\n\n\t}, {\n\t\tkey: 'getIgnoredOptions',\n\t\tvalue: function getIgnoredOptions() {\n\t\t\t// Return the ignore options\n\t\t\treturn {\n\t\t\t\tignorePaths: this.config.ignorePaths,\n\t\t\t\tignoreHiddenFiles: this.config.ignoreHiddenFiles,\n\t\t\t\tignoreCommonPatterns: this.config.ignoreCommonPatterns,\n\t\t\t\tignoreCustomPatterns: this.config.ignoreCustomPatterns\n\t\t\t};\n\t\t}\n\n\t\t/**\n  Check whether or not a path should be ignored or not based on our current configuration options\n  @private\n  @param {String} path - the path (likely of a child)\n  @returns {boolean}\n  */\n\n\t}, {\n\t\tkey: 'isIgnoredPath',\n\t\tvalue: function isIgnoredPath(path /* :string */) {\n\t\t\t// Ignore?\n\t\t\tvar ignore = ignorefs.isIgnoredPath(path, this.getIgnoredOptions());\n\n\t\t\t// Return\n\t\t\treturn ignore;\n\t\t}\n\n\t\t/**\n  Get the stat for the path of the watcher\n  If the stat already exists and `opts.reset` is `false`, then just use the current stat, otherwise fetch a new stat and apply it to the watcher\n  @param {Object} opts\n  @param {boolean} [opts.reset=false]\n  @param  {function} next - completion callback with signature `error:?Error, stat?:Stats`\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'getStat',\n\t\tvalue: function getStat(opts /* :ResetOpts */, next /* :StatCallback */) {\n\t\t\tvar _this4 = this;\n\n\t\t\t// Figure out what stat method we want to use\n\t\t\tvar method = this.config.followLinks ? 'stat' : 'lstat';\n\n\t\t\t// Fetch\n\t\t\tif (this.stat && opts.reset !== true) {\n\t\t\t\tnext(null, this.stat);\n\t\t\t} else {\n\t\t\t\tfsUtil[method](this.path, function (err, stat) {\n\t\t\t\t\tif (err) return next(err);\n\t\t\t\t\t_this4.stat = stat;\n\t\t\t\t\treturn next(null, stat);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Watch and WatchFile Listener\n  The listener attached to the `watch` and `watchFile` watching methods.\n  \tThings to note:\n  - `watchFile` method:\n  \t- Arguments:\n  \t\t- currentStat - the updated stat of the changed file\n  \t\t\t- Exists even for deleted/renamed files\n  \t\t- previousStat - the last old stat of the changed file\n  \t\t\t- Is accurate, however we already have this\n  \t- For renamed files, it will will fire on the directory and the file\n  - `watch` method:\n  \t- Arguments:\n  \t\t- eventName - either 'rename' or 'change'\n  \t\t\t- THIS VALUE IS ALWAYS UNRELIABLE AND CANNOT BE TRUSTED\n  \t\t- filename - child path of the file that was triggered\n  \t\t\t- This value can also be unrealiable at times\n  - both methods:\n  \t- For deleted and changed files, it will fire on the file\n  \t- For new files, it will fire on the directory\n  \tOutput arguments for your emitted event will be:\n  - for updated files the arguments will be: `'update', fullPath, currentStat, previousStat`\n  - for created files the arguments will be: `'create', fullPath, currentStat, null`\n  - for deleted files the arguments will be: `'delete', fullPath, null, previousStat`\n  \tIn the future we will add:\n  - for renamed files: 'rename', fullPath, currentStat, previousStat, newFullPath\n  - rename is possible as the stat.ino is the same for the delete and create\n  \t@private\n  @param {Object} opts\n  @param {string} [opts.method] - the watch method that was used\n  @param {Array<*>} [opts.args] - the arguments from the watching method\n  @param {function} [next] - the optional completion callback with the signature `(error:?Error)`\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'listener',\n\t\tvalue: function listener(opts /* :ListenerOpts */, next /* ::?:ErrorCallback */) {\n\t\t\tvar _this5 = this;\n\n\t\t\t// Prepare\n\t\t\tvar config = this.config;\n\t\t\tvar method = opts.method;\n\t\t\tif (!next) {\n\t\t\t\tnext = function next(err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t_this5.emit('error', err);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Prepare properties\n\t\t\tvar currentStat = null;\n\t\t\tvar previousStat = null;\n\n\t\t\t// Log\n\t\t\tthis.log('debug', 'watch via ' + method + ' method fired on: ' + this.path);\n\n\t\t\t// Delay the execution of the listener tasks, to once the change events have stopped firing\n\t\t\tif (this.listenerTimeout != null) {\n\t\t\t\tclearTimeout(this.listenerTimeout);\n\t\t\t}\n\t\t\tthis.listenerTimeout = setTimeout(function () {\n\t\t\t\tvar tasks = _this5.listenerTaskGroup;\n\t\t\t\tif (tasks) {\n\t\t\t\t\t_this5.listenerTaskGroup = null;\n\t\t\t\t\t_this5.listenerTimeout = null;\n\t\t\t\t\ttasks.run();\n\t\t\t\t} else {\n\t\t\t\t\t_this5.emit('error', new Error('unexpected state'));\n\t\t\t\t}\n\t\t\t}, config.catchupDelay || 0);\n\n\t\t\t// We are a subsequent listener, in which case, just listen to the first listener tasks\n\t\t\tif (this.listenerTaskGroup != null) {\n\t\t\t\tthis.listenerTaskGroup.done(next);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Start the detection process\n\t\t\tvar tasks = this.listenerTaskGroup = new TaskGroup('listener tasks for ' + this.path, { domain: false }).done(next);\n\t\t\ttasks.addTask('check if the file still exists', function (complete) {\n\t\t\t\t// Log\n\t\t\t\t_this5.log('debug', 'watch evaluating on: ' + _this5.path + ' [state: ' + _this5.state + ']');\n\n\t\t\t\t// Check if this is still needed\n\t\t\t\tif (_this5.state !== 'active') {\n\t\t\t\t\t_this5.log('debug', 'watch discarded on: ' + _this5.path);\n\t\t\t\t\ttasks.clearRemaining();\n\t\t\t\t\treturn complete();\n\t\t\t\t}\n\n\t\t\t\t// Check if the file still exists\n\t\t\t\tfsUtil.exists(_this5.path, function (exists) {\n\t\t\t\t\t// Apply local global property\n\t\t\t\t\tpreviousStat = _this5.stat;\n\n\t\t\t\t\t// If the file still exists, then update the stat\n\t\t\t\t\tif (exists === false) {\n\t\t\t\t\t\t// Log\n\t\t\t\t\t\t_this5.log('debug', 'watch emit delete: ' + _this5.path);\n\n\t\t\t\t\t\t// Apply\n\t\t\t\t\t\t_this5.stat = null;\n\t\t\t\t\t\t_this5.close('deleted');\n\t\t\t\t\t\t_this5.emit('change', 'delete', _this5.path, null, previousStat);\n\n\t\t\t\t\t\t// Clear the remaining tasks, as they are no longer needed\n\t\t\t\t\t\ttasks.clearRemaining();\n\t\t\t\t\t\treturn complete();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update the stat of the fil\n\t\t\t\t\t_this5.getStat({ reset: true }, function (err, stat) {\n\t\t\t\t\t\t// Check\n\t\t\t\t\t\tif (err) return complete(err);\n\n\t\t\t\t\t\t// Update\n\t\t\t\t\t\tcurrentStat = stat;\n\n\t\t\t\t\t\t// Complete\n\t\t\t\t\t\treturn complete();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\ttasks.addTask('check if the file has changed', function (complete) {\n\t\t\t\t// Ensure stats exist\n\t\t\t\tif (!currentStat || !previousStat) {\n\t\t\t\t\treturn complete(new Error('unexpected state'));\n\t\t\t\t}\n\n\t\t\t\t// Check if there is a different file at the same location\n\t\t\t\t// If so, we will need to rewatch the location and the children\n\t\t\t\tif (currentStat.ino.toString() !== previousStat.ino.toString()) {\n\t\t\t\t\t_this5.log('debug', 'watch found replaced: ' + _this5.path, currentStat, previousStat);\n\t\t\t\t\t// note this will close the entire tree of listeners and reinstate them\n\t\t\t\t\t// however, as this is probably for a file, it is probably not that bad\n\t\t\t\t\treturn _this5.watch({ reset: true }, complete);\n\t\t\t\t}\n\n\t\t\t\t// Check if the file or directory has been modified\n\t\t\t\tif (currentStat.mtime.toString() !== previousStat.mtime.toString()) {\n\t\t\t\t\t_this5.log('debug', 'watch found modification: ' + _this5.path, previousStat, currentStat);\n\t\t\t\t\treturn complete();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise it is the same, and nothing is needed to be done\n\t\t\t\telse {\n\t\t\t\t\t\ttasks.clearRemaining();\n\t\t\t\t\t\treturn complete();\n\t\t\t\t\t}\n\t\t\t});\n\n\t\t\ttasks.addGroup('check what has changed', function (addGroup, addTask, done) {\n\t\t\t\t// Ensure stats exist\n\t\t\t\tif (!currentStat || !previousStat) {\n\t\t\t\t\treturn done(new Error('unexpected state'));\n\t\t\t\t}\n\n\t\t\t\t// Set this sub group to execute in parallel\n\t\t\t\t_this5.setConfig({ concurrency: 0 });\n\n\t\t\t\t// So let's check if we are a directory\n\t\t\t\tif (currentStat.isDirectory() === false) {\n\t\t\t\t\t// If we are a file, lets simply emit the change event\n\t\t\t\t\t_this5.log('debug', 'watch emit update: ' + _this5.path);\n\t\t\t\t\t_this5.emit('change', 'update', _this5.path, currentStat, previousStat);\n\t\t\t\t\treturn done();\n\t\t\t\t}\n\n\t\t\t\t// We are a direcotry\n\t\t\t\t// Chances are something actually happened to a child (rename or delete)\n\t\t\t\t// and if we are the same, then we should scan our children to look for renames and deletes\n\t\t\t\tfsUtil.readdir(_this5.path, function (err, newFileRelativePaths) {\n\t\t\t\t\t// Error?\n\t\t\t\t\tif (err) return done(err);\n\n\t\t\t\t\t// Log\n\t\t\t\t\t_this5.log('debug', 'watch read dir: ' + _this5.path, newFileRelativePaths);\n\n\t\t\t\t\t// Find deleted files\n\t\t\t\t\teachr(_this5.children, function (child, childFileRelativePath) {\n\t\t\t\t\t\t// Skip if the file still exists\n\t\t\t\t\t\tif (newFileRelativePaths.indexOf(childFileRelativePath) !== -1) return;\n\n\t\t\t\t\t\t// Fetch full path\n\t\t\t\t\t\tvar childFileFullPath = pathUtil.join(_this5.path, childFileRelativePath);\n\n\t\t\t\t\t\t// Skip if ignored file\n\t\t\t\t\t\tif (_this5.isIgnoredPath(childFileFullPath)) {\n\t\t\t\t\t\t\t_this5.log('debug', 'watch ignored delete: ' + childFileFullPath + ' via: ' + _this5.path);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Emit the event and note the change\n\t\t\t\t\t\t_this5.log('debug', 'watch emit delete: ' + childFileFullPath + ' via: ' + _this5.path);\n\t\t\t\t\t\tvar childPreviousStat = child.watcher.stat;\n\t\t\t\t\t\tchild.close('deleted');\n\t\t\t\t\t\t_this5.emit('change', 'delete', childFileFullPath, null, childPreviousStat);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Find new files\n\t\t\t\t\teachr(newFileRelativePaths, function (childFileRelativePath) {\n\t\t\t\t\t\t// Skip if we are already watching this file\n\t\t\t\t\t\tif (_this5.children[childFileRelativePath] != null) return;\n\n\t\t\t\t\t\t// Fetch full path\n\t\t\t\t\t\tvar childFileFullPath = pathUtil.join(_this5.path, childFileRelativePath);\n\n\t\t\t\t\t\t// Skip if ignored file\n\t\t\t\t\t\tif (_this5.isIgnoredPath(childFileFullPath)) {\n\t\t\t\t\t\t\t_this5.log('debug', 'watch ignored create: ' + childFileFullPath + ' via: ' + _this5.path);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Emit the event and note the change\n\t\t\t\t\t\taddTask('watch the new child', function (complete) {\n\t\t\t\t\t\t\t_this5.log('debug', 'watch determined create: ' + childFileFullPath + ' via: ' + _this5.path);\n\t\t\t\t\t\t\tif (_this5.children[childFileRelativePath] != null) {\n\t\t\t\t\t\t\t\treturn complete(); // this should never occur\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar child = _this5.watchChild({\n\t\t\t\t\t\t\t\tfullPath: childFileFullPath,\n\t\t\t\t\t\t\t\trelativePath: childFileRelativePath\n\t\t\t\t\t\t\t}, function (err) {\n\t\t\t\t\t\t\t\tif (err) return complete(err);\n\t\t\t\t\t\t\t\t_this5.emit('change', 'create', childFileFullPath, child.watcher.stat, null);\n\t\t\t\t\t\t\t\treturn complete();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// Read the directory, finished adding tasks to the group\n\t\t\t\t\treturn done();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Tasks are executed via the timeout thing earlier\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Close the watching abilities of this watcher and its children if it has any\n  And mark the state as deleted or closed, dependning on the reason\n  @param {string} [reason='unknown']\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'close',\n\t\tvalue: function close() {\n\t\t\tvar reason /* :string */ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unknown';\n\n\t\t\t// Nothing to do? Already closed?\n\t\t\tif (this.state !== 'active') return this;\n\n\t\t\t// Close\n\t\t\tthis.log('debug', 'close: ' + this.path);\n\n\t\t\t// Close our children\n\t\t\teachr(this.children, function (child) {\n\t\t\t\tchild.close(reason);\n\t\t\t});\n\n\t\t\t// Close watch listener\n\t\t\tif (this.fswatcher != null) {\n\t\t\t\tthis.fswatcher.close();\n\t\t\t\tthis.fswatcher = null;\n\t\t\t} else {\n\t\t\t\tfsUtil.unwatchFile(this.path);\n\t\t\t}\n\n\t\t\t// Updated state\n\t\t\tif (reason === 'deleted') {\n\t\t\t\tthis.state = 'deleted';\n\t\t\t} else {\n\t\t\t\tthis.state = 'closed';\n\t\t\t}\n\n\t\t\t// Emit our close event\n\t\t\tthis.log('debug', 'watch closed because ' + reason + ' on ' + this.path);\n\t\t\tthis.emit('close', reason);\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Create the child watcher/stalker for a given sub path of this watcher with inherited configuration\n  Once created, attach it to `this.children` and bubble `log` and `change` events\n  If the child closes, then delete it from `this.children`\n  @private\n  @param {Object} opts\n  @param {string} opts.fullPath\n  @param {string} opts.relativePath\n  @param {Stats} [opts.stat]\n  @param {function} next - completion callback with signature `error:?Error`\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'watchChild',\n\t\tvalue: function watchChild(opts /* :WatchChildOpts */, next /* :ErrorCallback */) /* :Stalker */{\n\t\t\t// Prepare\n\t\t\tvar watchr = this;\n\n\t\t\t// Create the child\n\t\t\tvar child = create(opts.fullPath);\n\n\t\t\t// Apply the child\n\t\t\tthis.children[opts.relativePath] = child;\n\n\t\t\t// Add the extra listaeners\n\t\t\tchild.once('close', function () {\n\t\t\t\treturn delete watchr.children[opts.relativePath];\n\t\t\t});\n\t\t\tchild.on('log', function () {\n\t\t\t\tfor (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n\t\t\t\t\targs[_key3] = arguments[_key3];\n\t\t\t\t}\n\n\t\t\t\treturn watchr.emit.apply(watchr, ['log'].concat(args));\n\t\t\t});\n\t\t\tchild.on('change', function () {\n\t\t\t\tfor (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n\t\t\t\t\targs[_key4] = arguments[_key4];\n\t\t\t\t}\n\n\t\t\t\treturn watchr.emit.apply(watchr, ['change'].concat(args));\n\t\t\t});\n\n\t\t\t// Add the extra configuration\n\t\t\tchild.setConfig({\n\t\t\t\t// Custom\n\t\t\t\tstat: opts.stat,\n\n\t\t\t\t// Inherit\n\t\t\t\tinterval: this.config.interval,\n\t\t\t\tpersistent: this.config.persistent,\n\t\t\t\tcatchupDelay: this.config.catchupDelay,\n\t\t\t\tpreferredMethods: this.config.preferredMethods,\n\t\t\t\tignorePaths: this.config.ignorePaths,\n\t\t\t\tignoreHiddenFiles: this.config.ignoreHiddenFiles,\n\t\t\t\tignoreCommonPatterns: this.config.ignoreCommonPatterns,\n\t\t\t\tignoreCustomPatterns: this.config.ignoreCustomPatterns,\n\t\t\t\tfollowLinks: this.config.followLinks\n\t\t\t});\n\n\t\t\t// Start the watching\n\t\t\tchild.watch(next);\n\n\t\t\t// Return the child\n\t\t\treturn child;\n\t\t}\n\n\t\t/**\n  Read the directory at our given path and watch each child\n  @private\n  @param {Object} opts - not currently used\n  @param {function} next - completion callback with signature `error:?Error`\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'watchChildren',\n\t\tvalue: function watchChildren(opts /* :Object */, next /* :ErrorCallback */) {\n\t\t\t// Prepare\n\t\t\tvar watchr = this;\n\n\t\t\t// Check stat\n\t\t\tif (this.stat == null) {\n\t\t\t\tnext(new Error('unexpected state'));\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Cycle through the directory if necessary\n\t\t\tif (this.stat.isDirectory()) {\n\t\t\t\tscandir({\n\t\t\t\t\t// Path\n\t\t\t\t\tpath: this.path,\n\n\t\t\t\t\t// Options\n\t\t\t\t\tignorePaths: this.config.ignorePaths,\n\t\t\t\t\tignoreHiddenFiles: this.config.ignoreHiddenFiles,\n\t\t\t\t\tignoreCommonPatterns: this.config.ignoreCommonPatterns,\n\t\t\t\t\tignoreCustomPatterns: this.config.ignoreCustomPatterns,\n\t\t\t\t\trecurse: false,\n\n\t\t\t\t\t// Next\n\t\t\t\t\tnext: next,\n\n\t\t\t\t\t// File and Directory Actions\n\t\t\t\t\taction: function action(fullPath, relativePath, nextFile) {\n\t\t\t\t\t\t// Check we are still releveant\n\t\t\t\t\t\tif (watchr.state !== 'active') {\n\t\t\t\t\t\t\treturn nextFile(null, true); // skip without error\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Watch this child\n\t\t\t\t\t\twatchr.watchChild({ fullPath: fullPath, relativePath: relativePath }, nextFile);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tnext();\n\t\t\t}\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Setup the watching using the specified method\n  @private\n  @param {string} method\n  @param {function} next - completion callback with signature `error:?Error`\n  @returns {void}\n  */\n\n\t}, {\n\t\tkey: 'watchMethod',\n\t\tvalue: function watchMethod(method /* :MethodEnum */, next /* :ErrorCallback */) /* :void */{\n\t\t\tvar _this6 = this;\n\n\t\t\tif (method === 'watch') {\n\t\t\t\t// Check\n\t\t\t\tif (fsUtil.watch == null) {\n\t\t\t\t\tvar err = new Error('watch method is not supported on this environment, fs.watch does not exist');\n\t\t\t\t\tnext(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Watch\n\t\t\t\ttry {\n\t\t\t\t\tthis.fswatcher = fsUtil.watch(this.path, function () {\n\t\t\t\t\t\tfor (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n\t\t\t\t\t\t\targs[_key5] = arguments[_key5];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn _this6.listener({ method: method, args: args });\n\t\t\t\t\t});\n\t\t\t\t\t// must pass the listener here instead of doing fswatcher.on('change', opts.listener)\n\t\t\t\t\t// as the latter is not supported on node 0.6 (only 0.8+)\n\t\t\t\t} catch (err) {\n\t\t\t\t\tnext(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Success\n\t\t\t\tnext();\n\t\t\t\treturn;\n\t\t\t} else if (method === 'watchFile') {\n\t\t\t\t// Check\n\t\t\t\tif (fsUtil.watchFile == null) {\n\t\t\t\t\tvar _err = new Error('watchFile method is not supported on this environment, fs.watchFile does not exist');\n\t\t\t\t\tnext(_err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Watch\n\t\t\t\ttry {\n\t\t\t\t\tfsUtil.watchFile(this.path, {\n\t\t\t\t\t\tpersistent: this.config.persistent,\n\t\t\t\t\t\tinterval: this.config.interval\n\t\t\t\t\t}, function () {\n\t\t\t\t\t\tfor (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n\t\t\t\t\t\t\targs[_key6] = arguments[_key6];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn _this6.listener({ method: method, args: args });\n\t\t\t\t\t});\n\t\t\t\t} catch (err) {\n\t\t\t\t\tnext(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Success\n\t\t\t\tnext();\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tvar _err2 = new Error('unknown watch method');\n\t\t\t\tnext(_err2);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/**\n  Setup watching for our path, in the order of the preferred methods\n  @private\n  @param {Object} opts\n  @param {Array<Error>} [opts.errors] - the current errors that we have received attempting the preferred methods\n  @param {Array<string>} [opts.preferredMethods] - fallback to the configuration if not specified\n  @param {function} next - completion callback with signature `error:?Error`\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'watchSelf',\n\t\tvalue: function watchSelf(opts /* :WatchSelfOpts */, next /* :ErrorCallback */) {\n\t\t\tvar _this7 = this;\n\n\t\t\t// Prepare\n\t\t\tvar _opts$errors = opts.errors;\n\t\t\tvar errors = _opts$errors === undefined ? [] : _opts$errors;\n\t\t\tvar _opts$preferredMethod = opts.preferredMethods;\n\t\t\tvar preferredMethods = _opts$preferredMethod === undefined ? this.config.preferredMethods : _opts$preferredMethod;\n\n\t\t\topts.errors = errors;\n\t\t\topts.preferredMethods = preferredMethods;\n\n\t\t\t// Attempt the watch methods\n\t\t\tif (preferredMethods.length) {\n\t\t\t\tvar method = preferredMethods[0];\n\t\t\t\tthis.watchMethod(method, function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\t// try again with the next preferred method\n\t\t\t\t\t\tpreferredMethods = preferredMethods.slice(1);\n\t\t\t\t\t\terrors.push(err);\n\t\t\t\t\t\t_this7.watchSelf({ errors: errors, preferredMethods: preferredMethods }, next);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply\n\t\t\t\t\t_this7.state = 'active';\n\n\t\t\t\t\t// Forward\n\t\t\t\t\tnext();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar _errors = opts.errors.map(function (error) {\n\t\t\t\t\treturn error.stack || error.message || error;\n\t\t\t\t}).join('\\n');\n\t\t\t\tvar err = new Error('no watch methods left to try, failures are:\\n' + _errors);\n\t\t\t\tnext(err);\n\t\t\t}\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n  Setup watching for our path, and our children\n  If we are already watching and `opts.reset` is not `true` then all done\n  Otherwise, close the current watchers for us and the children via {@link Watcher#close} and setup new ones\n  @public\n  @param {Object} [opts]\n  @param {boolean} [opts.reset=false] - should we always close existing watchers and setup new watchers\n  @param {function} next - completion callback with signature `error:?Error`\n  @param {Array<*>} args - ignore this argument, it is used just to handle the optional `opts` argument\n  @returns {this}\n  */\n\n\t}, {\n\t\tkey: 'watch',\n\t\tvalue: function watch() /* :Array<any> */{\n\t\t\tvar _this8 = this;\n\n\t\t\t// Handle overloaded signature\n\t\t\tvar opts = void 0 /* :ResetOpts */,\n\t\t\t    next = void 0; /* :ErrorCallback */\n\t\t\tif (arguments.length === 1) {\n\t\t\t\topts = {};\n\t\t\t\tnext = arguments.length <= 0 ? undefined : arguments[0];\n\t\t\t} else if (arguments.length === 2) {\n\t\t\t\topts = arguments.length <= 0 ? undefined : arguments[0];\n\t\t\t\tnext = arguments.length <= 1 ? undefined : arguments[1];\n\t\t\t} else {\n\t\t\t\tthrow new Error('unknown arguments');\n\t\t\t}\n\n\t\t\t// Check\n\t\t\tif (this.state === 'active' && opts.reset !== true) {\n\t\t\t\tnext();\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Close our all watch listeners\n\t\t\tthis.close();\n\n\t\t\t// Log\n\t\t\tthis.log('debug', 'watch init: ' + this.path);\n\n\t\t\t// Fetch the stat then try again\n\t\t\tthis.getStat({}, function (err) {\n\t\t\t\tif (err) return next(err);\n\n\t\t\t\t// Watch ourself\n\t\t\t\t_this8.watchSelf({}, function (err) {\n\t\t\t\t\tif (err) return next(err);\n\n\t\t\t\t\t// Watch the children\n\t\t\t\t\t_this8.watchChildren({}, function (err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t_this8.close('child failure');\n\t\t\t\t\t\t\t_this8.log('debug', 'watch failed on [' + _this8.path + '] with ' + errorToString(err));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_this8.log('debug', 'watch success on [' + _this8.path + ']');\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn next(err);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Chain\n\t\t\treturn this;\n\t\t}\n\t}]);\n\n\treturn Watcher;\n}(EventEmitter);\n\n// Now let's provide node.js with our public API\n// In other words, what the application that calls us has access to\n\n\nmodule.exports = { open: open, create: create, Stalker: Stalker, Watcher: Watcher };"}